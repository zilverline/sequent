# frozen_string_literal: true

require 'spec_helper'
require 'active_support/hash_with_indifferent_access'
require_relative '../fixtures/spec_migrations'

describe Sequent::Migrations::ProjectorsReplayer do
  before :each do
    SpecMigrations.reset
    Sequent::Migrations::ReplayState.delete_all
    exec_update('DROP TABLE IF EXISTS view_schema.single_records')
    exec_update(<<~SQL)
      CREATE TABLE view_schema.single_records (
        id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        aggregate_id uuid NOT NULL UNIQUE,
        name text NOT NULL
      )
    SQL
    state = Sequent::Migrations::ReplayState.last
    exec_update("DROP SCHEMA IF EXISTS #{state.replay_schema} CASCADE") if state
  end
  after do
    Sequent::Migrations::ReplayState.delete_all
    state = Sequent::Migrations::ReplayState.last
    exec_update("DROP SCHEMA IF EXISTS #{state.replay_schema} CASCADE") if state
    exec_update('DROP TABLE IF EXISTS view_schema.single_records')
  end

  class DummyCommand < Sequent::Core::BaseCommand; end
  class ProjectorsReplayEvent1 < Sequent::Core::Event
    attrs name: String
  end

  class ProjectorsReplayEvent2 < Sequent::Core::Event
    attrs name: String
  end

  class ProjectorsReplayTestAggregate < Sequent::Core::AggregateRoot
    attr_reader :name

    def events_partition_key = name[0..2]

    def initialize(aggregate_id:, name:)
      super(aggregate_id)
      apply ProjectorsReplayEvent1, name:
    end

    on ProjectorsReplayEvent1 do |event|
      @name = event.name
    end
  end

  class SingleRecord < ActiveRecord::Base
  end

  class SingleRecordProjector < Sequent::Core::Projector
    manages_tables SingleRecord

    on ProjectorsReplayEvent1 do |event|
      create_record(SingleRecord, {aggregate_id: event.aggregate_id, name: event.name})
    end
  end

  let(:db_config) { Database.test_config }
  let(:projector_classes) { [SingleRecordProjector] }

  subject { Sequent::Migrations::ProjectorsReplayer.create!(db_config:, projector_classes:) }

  def replay_state = Sequent::Migrations::ReplayState.last

  def insert_events(count)
    transaction do
      count.times do |i|
        Sequent.aggregate_repository.add_aggregate ProjectorsReplayTestAggregate.new(
          aggregate_id: Sequent.new_uuid,
          name: "#{i} aggregate",
        )
      end
      Sequent.aggregate_repository.commit(DummyCommand.new)
    end
  end

  context '#prepare_for_replay' do
    before do
      subject.prepare_for_replay
    end

    it 'should create a replay schema containing empty tables' do
      expect(replay_state).to have_attributes(state: 'prepared')

      expect(query_schemas).to include(subject.replay_schema_name)

      tables = exec_query('SELECT tablename FROM pg_tables WHERE schemaname = $1', [subject.replay_schema_name]).to_a
      expect(tables).to contain_exactly('tablename' => 'single_records')
    end

    it 'should fail if already prepared' do
      expect do
        subject.prepare_for_replay
      end.to raise_error(/when current state is `created`/)
    end
  end

  context '#done!' do
    before do
      subject.prepare_for_replay
      subject.done!
    end

    it 'should remove the replay schema name' do
      expect(query_schemas).to_not include(subject.replay_schema_name)
    end

    it 'should allow preparing for replay again' do
      old_replay_state = Sequent::Migrations::ReplayState.last

      replayer = Sequent::Migrations::ProjectorsReplayer.create!(db_config:, projector_classes: [SingleRecordProjector])
      replayer.prepare_for_replay

      new_replay_state = Sequent::Migrations::ReplayState.last
      expect(old_replay_state.id).to_not eq(new_replay_state.id)
    end
  end

  context '#initial_replay' do
    let(:initial_event_count) { 1000 }

    before do
      insert_events(initial_event_count)

      subject.prepare_for_replay
    end

    it 'should fail if the state is not `prepared`' do
      subject.done!

      expect { subject.perform_initial_replay }
        .to raise_error(/initial replay can only be performed when current state is `prepared`/)
    end

    it 'should ensure the replay tables are empty for the initial replay' do
      in_replay_schema do
        SingleRecord.create!(aggregate_id: Sequent.new_uuid, name: 'name')
      end

      expect { subject.perform_initial_replay }.to raise_error(/not empty/)
    end

    context 'after initial replay is performed' do
      before do
        subject.perform_initial_replay
      end

      it 'should have replayed to the replay schema table' do
        expect(exec_query("SELECT COUNT(*) FROM #{subject.replay_schema_name}.single_records").to_a)
          .to eq(['count' => initial_event_count])
      end

      it 'should not affect the view schema tables' do
        expect(exec_query('SELECT COUNT(*) FROM view_schema.single_records').to_a).to eq(['count' => 0])
      end

      it 'should be ready for incremental replay and activation' do
        expect(replay_state).to have_attributes(state: 'ready_for_activation')
      end

      context '#incremental_replay' do
        let(:incremental_event_count) { 800 }

        before do
          insert_events(incremental_event_count)
          subject.perform_incremental_replay
        end

        it 'only processes the new events' do
          expect(exec_query("SELECT COUNT(*) FROM #{subject.replay_schema_name}.single_records").to_a)
            .to eq(['count' => initial_event_count + incremental_event_count])
        end

        it 'can be executed multiple times' do
          extra_event_count = incremental_event_count / 10

          insert_events(extra_event_count)
          subject.perform_incremental_replay

          expect(exec_query("SELECT COUNT(*) FROM #{subject.replay_schema_name}.single_records").to_a)
            .to eq(['count' => initial_event_count + incremental_event_count + extra_event_count])
        end

        it 'can be executed without any more pending events' do
          subject.perform_incremental_replay

          expect(exec_query("SELECT COUNT(*) FROM #{subject.replay_schema_name}.single_records").to_a)
            .to eq(['count' => initial_event_count + incremental_event_count])
        end
      end
    end
  end

  context '#switch_replayed_projectors' do
    xit 'should fail if projector state tracking is not enabled' do
    end
  end

  def exec_query(sql, binds = []) = ActiveRecord::Base.connection.exec_query(sql, 'query', binds)
  def exec_update(sql, binds = []) = ActiveRecord::Base.connection.exec_update(sql, 'update', binds)
  def query_schemas = exec_query('SELECT nspname FROM pg_namespace').map { |r| r['nspname'] }

  def transaction(...) = Sequent.configuration.transaction_provider.transactional(...)

  def in_replay_schema
    transaction do
      exec_update("SET LOCAL search_path TO #{subject.replay_schema_name}")
      yield
    end
  end
end
